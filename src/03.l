# Jó lenne reguláris kifejezéseket használni a harmadik feladatnál, de azok is
# hiányoznak a nyelvből. Épp ezért implementáljuk a konkrét elemző automatát mi!

(de digit (C) (and (<= "0" C) (<= C "9")))
(de digitValue (C) (- (char C) (char "0")))
(de shiftOne (C X) (let Y (digitValue C) (+ Y (* 10 X))))
(de sumProduct (P A B) (+ P (* A B)))
(de dfa (F)
   (in F
      (let (I 0 A 0 B 0 P 0)
         (until (eof)
            (let C (char)
               (cond
                  ((and (= I 0) (= C "m")) (setq I 1))
                  ((and (= I 1) (= C "u")) (setq I 2))
                  ((and (= I 2) (= C "l")) (setq I 3))
                  ((and (= I 3) (= C "(")) (setq I 4))
                  ((and (= I 4) (digit C)) (setq I 5 A (digitValue C)))
                  ((and (= I 5) (digit C)) (setq I 6 A (shiftOne C A)))
                  ((and (= I 5) (= C ",")) (setq I 8))
                  ((and (= I 6) (digit C)) (setq I 7 A (shiftOne C A)))
                  ((and (= I 6) (= C ",")) (setq I 8))
                  ((and (= I 7) (= C ",")) (setq I 8))
                  ((and (= I 8) (digit C)) (setq I 9 B (digitValue C)))
                  ((and (= I 9) (digit C)) (setq I 10 B (shiftOne C B)))
                  ((and (= I 9) (= C ")")) (setq I 0 P (sumProduct P A B)))
                  ((and (= I 10) (digit C)) (setq I 11 B (shiftOne C B)))
                  ((and (= I 10) (= C ")")) (setq I 0 P (sumProduct P A B)))
                  ((and (= I 11) (= C ")")) (setq I 0 P (sumProduct P A B)))
                  (T (setq I 0)) )
               ))
         P)))

(de dfa2 (F)
   (in F
      (let (I 0 A 0 B 0 P 0)
         (until (eof)
            (let C (char)
               (cond
                  ((and (= I 0) (= C "m")) (setq I 1))
                  ((and (= I 0) (= C "d")) (setq I 12))
                  ((and (= I 1) (= C "u")) (setq I 2))
                  ((and (= I 2) (= C "l")) (setq I 3))
                  ((and (= I 3) (= C "(")) (setq I 4))
                  ((and (= I 4) (digit C)) (setq I 5 A (digitValue C)))
                  ((and (= I 5) (digit C)) (setq I 6 A (shiftOne C A)))
                  ((and (= I 5) (= C ",")) (setq I 8))
                  ((and (= I 6) (digit C)) (setq I 7 A (shiftOne C A)))
                  ((and (= I 6) (= C ",")) (setq I 8))
                  ((and (= I 7) (= C ",")) (setq I 8))
                  ((and (= I 8) (digit C)) (setq I 9 B (digitValue C)))
                  ((and (= I 9) (digit C)) (setq I 10 B (shiftOne C B)))
                  ((and (= I 9) (= C ")")) (setq I 0 P (sumProduct P A B)))
                  ((and (= I 10) (digit C)) (setq I 11 B (shiftOne C B)))
                  ((and (= I 10) (= C ")")) (setq I 0 P (sumProduct P A B)))
                  ((and (= I 11) (= C ")")) (setq I 0 P (sumProduct P A B)))
                  ((and (= I 12) (= C "o")) (setq I 13))
                  ((and (= I 13) (= C "(")) (setq I 14))
                  ((and (= I 13) (= C "n")) (setq I 15))
                  ((and (= I 14) (= C ")")) (setq I 0))
                  ((and (= I 15) (= C "'")) (setq I 16))
                  ((and (= I 16) (= C "t")) (setq I 17))
                  ((and (= I 17) (= C "(")) (setq I 18))
                  ((and (= I 18) (= C ")")) (setq I 19))
                  ((and (= I 19) (= C "d")) (setq I 12))
                  ((= I 19) (setq I 19))
                  (T (setq I 0)) )
               ))
         P)))
